#!/usr/bin/env python3
"""
Make perâ€‘MUTANT mutation maps for bacterial genomes from an Excel table.

Input Excel is expected to have columns (case-sensitive):
  - "#CHROM"   (chromosome/contig accession)
  - "MUTANT"   (mutant/sample identifier)
  - "POS"      (1-based genomic position of mutation)
  - "%REF"     (percentage of reference allele; may use comma decimal separator)

Other columns are ignored. The Excel workbook may have a single sheet or multiple; by default
we read the first sheet unless --sheet is provided.

For each MUTANT, this script produces a horizontal line for every chromosome (present in that MUTANT),
with short vertical ticks at every mutation position on that chromosome.
Tick color rule: red if %REF == 0 (after parsing), otherwise black.

Outputs (per mutant):
  figures/{MUTANT}_mutations.png
  figures/{MUTANT}_mutations.svg

Usage:
  python scripts/make_mutation_maps.py \
      --excel data/all_mutants_vcf_with_genes_14082025.xlsx \
      --outdir figures \
      --sheet all

Author: generated by ChatGPT for Misha
"""
from __future__ import annotations

import argparse
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable, Optional

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt


# -------------------------
# Data loading & cleaning
# -------------------------

REQUIRED_COLUMNS = ["#CHROM", "MUTANT", "POS", "%REF"]


def _parse_percent_ref(val: object) -> Optional[float]:
    """Parse %REF values that may use comma decimal separators.

    Returns a float in [0, 100] or None if parsing fails.
    """
    if val is None:
        return None
    if isinstance(val, (int, float)) and not pd.isna(val):
        return float(val)
    s = str(val).strip()
    if s == "" or s.lower() in {"nan", "na"}:
        return None
    # replace comma decimal separator
    s = s.replace(",", ".")
    try:
        return float(s)
    except ValueError:
        return None


@dataclass(frozen=True)
class PlotConfig:
    line_width: float = 2.0
    tick_height: float = 0.6  # relative to row spacing
    tick_width: float = 0.8
    dpi: int = 200
    figsize_per_row: float = 0.45  # inches per chromosome line
    left_margin_in: float = 0.9
    right_margin_in: float = 0.3
    top_margin_in: float = 0.6
    bottom_margin_in: float = 0.8
    baseline_color: str = "#bfbfbf"  # gray genome line
    bar_width_ratio: float = 0.22  # fraction of total width for the right bar subplot
    bar_edgecolor: Optional[str] = None  # keep None for flat blocks


def load_mutation_table(excel_path: Path, sheet: Optional[str] = None) -> pd.DataFrame:
    """Load and normalize the mutation table from Excel.

    Ensures required columns exist, coerces types, and standardizes column names.
    """
    if sheet is None:
        df = pd.read_excel(excel_path)
    else:
        df = pd.read_excel(excel_path, sheet_name=sheet)

    missing = [c for c in REQUIRED_COLUMNS if c not in df.columns]
    if missing:
        raise ValueError(
            f"Missing required columns in {excel_path}: {missing}.\n"
            f"Available columns: {list(df.columns)}"
        )

    # Coerce types
    df = df.copy()
    df["#CHROM"] = df["#CHROM"].astype(str)
    df["MUTANT"] = df["MUTANT"].astype(str)
    # POS may come as numeric already, but ensure int
    df["POS"] = pd.to_numeric(df["POS"], errors="coerce").astype("Int64")
    # Parse %REF with potential comma decimals
    df["PCT_REF"] = df["%REF"].map(_parse_percent_ref)

    # drop rows with missing essential info
    df = df.dropna(subset=["POS"]).copy()
    df["POS"] = df["POS"].astype(int)

    return df


# -------------------------
# Plotting
# -------------------------

def _compute_axes_size(n_rows: int, cfg: PlotConfig) -> tuple[float, float]:
    height = max(cfg.bottom_margin_in + cfg.top_margin_in + n_rows * cfg.figsize_per_row, 2.0)
    # Width allocates room for map + bar; keep total ~10 in
    width = 10.0
    return width, height


def plot_mutations_for_mutant(df_mutant: pd.DataFrame, mutant: str, outdir: Path, cfg: PlotConfig) -> None:
    """Create and save a mutation map figure for one MUTANT.

    Rows correspond to chromosomes ("#CHROM") present in this mutant's records.
    For each row, draw a horizontal line from 0 to max POS on that chromosome,
    and vertical ticks at each mutation position.
    """
    chrom_order = (
        df_mutant.groupby("#CHROM")["POS"].max().sort_values(ascending=False).index.tolist()
    )  # longest first by max mutation position observed
    n = len(chrom_order)

    width_in, height_in = _compute_axes_size(n, cfg)
    fig = plt.figure(figsize=(width_in, height_in), dpi=cfg.dpi)
    # allocate a slim right column for the stacked bar plot
    bar_ratio = max(min(cfg.bar_width_ratio, 0.45), 0.05)
    gs = fig.add_gridspec(1, 2, width_ratios=[1.0 - bar_ratio, bar_ratio], wspace=0.25)
    ax = fig.add_subplot(gs[0, 0])
    ax_bar = fig.add_subplot(gs[0, 1])

    # Y positions: highest at top
    y_positions = {chrom: i for i, chrom in enumerate(range(n, 0, -1), start=0)}
    # But we actually want explicit mapping: top row index n..1 mapped to labels
    # Simpler: create mapping label -> y coordinate (1..n)
    y_map = {chrom: idx for idx, chrom in enumerate(chrom_order[::-1], start=1)}

    # Global x-limit: max POS across this mutant (to align rows)
    xmax = int(df_mutant["POS"].max()) if not df_mutant.empty else 1
    xmin = 0

    # Draw chromosome baselines
    for chrom in chrom_order:
        y = y_map[chrom]
        chrom_max = int(df_mutant.loc[df_mutant["#CHROM"] == chrom, "POS"].max())
        ax.hlines(y=y, xmin=xmin, xmax=chrom_max, linewidth=cfg.line_width, color=cfg.baseline_color)

    # Draw mutation ticks
    for _, row in df_mutant.iterrows():
        y = y_map[row["#CHROM"]]
        x = int(row["POS"])  # position
        # vertical tick centered on y, height relative to 1.0 row spacing
        tick_half = cfg.tick_height / 2.0
        color = "red" if (row["PCT_REF"] is not None and not np.isnan(row["PCT_REF"]) and float(row["PCT_REF"]) == 0.0) else "black"
        ax.vlines(x=x, ymin=y - tick_half, ymax=y + tick_half, linewidth=cfg.tick_width, color=color)

    # Axes formatting (left plot)
    ax.set_xlim(xmin, xmax * 1.02)
    ax.set_ylim(0, n + 1)
    ax.set_yticks([y_map[c] for c in chrom_order])
    ax.set_yticklabels(chrom_order)
    ax.set_xlabel("Position (bp)")
    ax.set_ylabel("#CHROM")
    ax.set_title(f"Mutations in {mutant}")
    ax.grid(axis="x", linestyle=":", alpha=0.4)

    # ---------------- Right subplot: stacked horizontal bar plot ----------------
    # Count mutations per chromosome: gray = present in reference (PCT_REF != 0), red = mutant-only (PCT_REF == 0)
    def _is_mut_only(v: Optional[float]) -> bool:
        return (v is not None) and (not np.isnan(v)) and (float(v) == 0.0)

    counts = (
        df_mutant.assign(is_mut_only=df_mutant["PCT_REF"].apply(_is_mut_only))
        .groupby("#CHROM")
        .agg(count_mut_only=("is_mut_only", "sum"), count_total=("POS", "count"))
        .reindex(chrom_order)
    )
    counts["count_both"] = counts["count_total"] - counts["count_mut_only"]

    y_vals = [y_map[c] for c in chrom_order]
    ax_bar.barh(y=y_vals, width=counts["count_both"].to_numpy(), left=0, color=cfg.baseline_color, edgecolor=cfg.bar_edgecolor, label="ref+mut")
    ax_bar.barh(y=y_vals, width=counts["count_mut_only"].to_numpy(), left=counts["count_both"].to_numpy(), color="red", edgecolor=cfg.bar_edgecolor, label="mut-only")

    ax_bar.set_ylim(0, n + 1)
    ax_bar.set_yticks(y_vals)
    ax_bar.set_yticklabels([])
    ax_bar.set_xlabel("Mutations")
    xmax_bar = int(max(1, counts["count_total"].max()))
    ax_bar.set_xlim(0, xmax_bar * 1.15)
    ax_bar.grid(axis="x", linestyle=":", alpha=0.3)
    ax_bar.legend(loc="upper right", frameon=False, fontsize=9)

    fig.tight_layout()

    outdir.mkdir(parents=True, exist_ok=True)
    png_path = outdir / f"{mutant}_mutations.png"
    svg_path = outdir / f"{mutant}_mutations.svg"
    fig.savefig(png_path)
    fig.savefig(svg_path)
    plt.close(fig)


# -------------------------
# Orchestration
# -------------------------

def make_all_plots(df: pd.DataFrame, outdir: Path, cfg: Optional[PlotConfig] = None) -> None:
    cfg = cfg or PlotConfig()
    for mutant, df_mut in df.groupby("MUTANT", sort=True):
        plot_mutations_for_mutant(df_mut, mutant, outdir, cfg)


def parse_args() -> argparse.Namespace:
    p = argparse.ArgumentParser(description="Make per-MUTANT mutation maps from Excel.")
    p.add_argument("--excel", type=Path, required=True, help="Path to the Excel file with mutations.")
    p.add_argument("--sheet", type=str, default=None, help="Worksheet name; default: first sheet")
    p.add_argument("--outdir", type=Path, default=Path("figures"), help="Output directory for figures")
    return p.parse_args()


def main() -> None:
    args = parse_args()
    df = load_mutation_table(args.excel, sheet=args.sheet)
    make_all_plots(df, args.outdir)


if __name__ == "__main__":
    main()
